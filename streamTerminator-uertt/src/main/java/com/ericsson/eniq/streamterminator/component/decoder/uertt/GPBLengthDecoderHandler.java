/*------------------------------------------------------------------------------
 *******************************************************************************
 * COPYRIGHT Ericsson 2013
 *
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 *******************************************************************************
 *----------------------------------------------------------------------------*/
package com.ericsson.eniq.streamterminator.component.decoder.uertt;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;

/**
 * <p>
 * {@link GPBLengthDecoderHandler} - shall be the first upstream handler in the pipeline. 
 * Should be used to split bytes received from the stream into discrete events.
 * </p>
 * 
 * <b>WARNING: Decoder is NOT sharable across different pipelines</b>
 * 
 * <p>
 * 
 * <b>Assumptions:</b>
 * <ul>
 * <li>Decoder STRIPS first 2 bytes from events its receives! <b> The assumption is that received events are not going to be longer than 64K! </b></li> 
 * <li>Decoder will preallocate 4 byte for stream out protocol to save object allocation, and reduce GC pressure.
 *  Thus it can be used only with stream out protocol</li>
 * </ul>
 * </p>
 * 
 * @author emaomic - marko.milenkovic@ericsson.com - Jan, 2014.
 * @see https://confluence-oss.lmera.ericsson.se/display/PMSTREAM/StreamOut+protocol
 */
public class GPBLengthDecoderHandler extends LengthFieldBasedFrameDecoder {
	
    private static final int LENGTH_FIELD_OFFSET = 0;
    private static final int LENGTH_FIELD_LENGTH = 4;
    private static final int LENGTH_ADJUSTMENT = 4;
    private static final int INITIAL_BYTES_TO_STRIP = 2;

    private static final int MAX_FRAME_LENGTH = 64*1024;

    private static final int HEADER_OFFSET = 4;
    private static final int STATIC_PART = 6;
    
    //
    // The event used for testing 
    //
    
    //    private static final byte[] EVENT = new byte[] { 0x00, 0x00, 0x01, 0x21, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x10, 0x08, 0x00, 0x0F, 0x10, 0x09, 0x18,
    //            0x04, 0x20, 0x0B, 0x28, 0x0C, 0x30, 0x1C, 0x38, 0x00, 0x01, 0x12, 0x00, 0x01, 0x0A, 0x00, 0x01, 0x0A, 0x03, 0x31, 0x2D, 0x31, 0x12, 0x03,
    //            0x43, 0x4D, 0x31, 0x1A, 0x19, 0x08, 0x00, 0x12, 0x15, 0x33, 0x47, 0x50, 0x50, 0x20, 0x54, 0x53, 0x20, 0x32, 0x35, 0x2E, 0x33, 0x33, 0x31,
    //            0x20, 0x56, 0x39, 0x2E, 0x32, 0x2E, 0x30, 0x1A, 0x14, 0x08, 0x01, 0x12, 0x10, 0x30, 0x2E, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x32, 0x30,
    //            0x2E, 0x33, 0x2E, 0x32, 0x2E, 0x31, 0x1A, 0x14, 0x08, 0x02, 0x12, 0x10, 0x30, 0x2E, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x32, 0x30, 0x2E,
    //            0x33, 0x2E, 0x30, 0x2E, 0x31, 0x1A, 0x14, 0x08, 0x04, 0x12, 0x10, 0x30, 0x2E, 0x34, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x32, 0x30, 0x2E, 0x33,
    //            0x2E, 0x31, 0x2E, 0x31, 0x1A, 0x04, 0x08, 0x05, 0x12, 0x00, 0x1A, 0x19, 0x08, 0x06, 0x12, 0x15, 0x33, 0x47, 0x50, 0x50, 0x20, 0x54, 0x53,
    //            0x20, 0x32, 0x35, 0x2E, 0x34, 0x35, 0x33, 0x20, 0x56, 0x37, 0x2E, 0x36, 0x2E, 0x30, 0x1A, 0x19, 0x08, 0x07, 0x12, 0x15, 0x33, 0x47, 0x50,
    //            0x50, 0x20, 0x54, 0x53, 0x20, 0x32, 0x35, 0x2E, 0x34, 0x31, 0x39, 0x20, 0x56, 0x36, 0x2E, 0x32, 0x2E, 0x30, 0x12, 0x15, 0x0A, 0x09, 0x20,
    //            0x0B, 0x28, 0x0C, 0x30, 0x1B, 0x38, 0x00, 0x05, 0x10, 0x00, 0x18, 0x08, 0x20, 0x00, 0x24, 0x28, 0x00, 0x4E, 0x1A, 0x10, 0x08, 0x00, 0x4E,
    //            0x12, 0x09, 0x20, 0x0B, 0x28, 0x0C, 0x30, 0x1B, 0x38, 0x00, 0x05, 0x20, 0x01, 0x22, 0x15, 0x0A, 0x09, 0x20, 0x0B, 0x28, 0x0C, 0x30, 0x1B,
    //            0x38, 0x00, 0x05, 0x12, 0x06, 0x52, 0x4E, 0x43, 0x32, 0x35, 0x32, 0x1A, 0x00, 0x1A, 0x24, 0x0A, 0x04, 0x00, 0x04, 0x00, 0x00, 0x10, 0x00,
    //            0x00, 0x00, 0x2C, 0x18, 0x00, 0x03, 0x22, 0x14, 0x08, 0x00, 0x24, 0x10, 0x08, 0x22, 0x0D, 0x00, 0x18, 0x0A, 0x0A, 0x08, 0x24, 0x09, 0x01,
    //            0x10, 0x09, 0x00, 0x11, 0x00 };

    public GPBLengthDecoderHandler() {
        super(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP);

    }

    //
    // in order to decrease GC pressure generated by CompositeByteBuff, header allocation, and
    // overall object creation rate we have override  extractFrame method to allocate 4 more bytes
    // problem whit this change is that all components must handle 4 extra bytes
    // more details at http://jira-oss.lmera.ericsson.se/browse/TORF-5735
    //

    @Override
    protected ByteBuf extractFrame(final ChannelHandlerContext ctx, final ByteBuf buffer, final int index, final int length) {

        final ByteBuf frame = ctx.alloc().buffer(length + HEADER_OFFSET); // allocate 4 bytes for stream out header
        // first 4 bytes should be 0
        frame.writeInt(0);
        frame.writeBytes(buffer, index, length);
        final int l = frame.getUnsignedShort(HEADER_OFFSET);
        frame.setShort(HEADER_OFFSET, l + STATIC_PART);

        return frame;
    }
}
